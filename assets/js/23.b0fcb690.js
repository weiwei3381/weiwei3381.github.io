(window.webpackJsonp=window.webpackJsonp||[]).push([[23],{386:function(v,_,t){"use strict";t.r(_);var e=t(19),o=Object(e.a)({},(function(){var v=this,_=v.$createElement,t=v._self._c||_;return t("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[t("h1",{attrs:{id:"深入理解es6"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#深入理解es6"}},[v._v("#")]),v._v(" 深入理解ES6")]),v._v(" "),t("h2",{attrs:{id:"《深入理解es6》读书笔记"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#《深入理解es6》读书笔记"}},[v._v("#")]),v._v(" 《深入理解ES6》读书笔记")]),v._v(" "),t("h3",{attrs:{id:"作用域"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#作用域"}},[v._v("#")]),v._v(" 作用域")]),v._v(" "),t("p",[v._v("Javascript有"),t("em",[v._v("函数作用域")]),v._v("和"),t("em",[v._v("全局作用域")]),v._v(", 并"),t("strong",[v._v("没有块作用域")]),v._v(". 关键字"),t("code",[v._v("var")]),v._v("或者"),t("code",[v._v("function")]),v._v("声明的变量会被"),t("strong",[v._v("提升")]),v._v(", 即无论在作用域的哪里声明, 在解析时都会放到作用域的顶部.")]),v._v(" "),t("p",[v._v("关键词"),t("code",[v._v("let")]),v._v("和"),t("code",[v._v("const")]),v._v("可以创建块级作用域, 它们声明的变量不会提升，而且只可以在声明这些变量的代码块中使用。如此一来，JavaScript声明变量的语法与其他语言更相似了，同时也大幅降低了产生错误的几率，因为变量只会在需要它们的地方声明。与此同时，这一新特性还存在一个副作用，即不能在声明变量前访问它们，就算用typeof这样安全的操作符也不行。在声明前访问块级绑定会导致错误，因为变量还绑定在临时死区(TDZ)中。"),t("br"),v._v(" "),t("code",[v._v("let")]),v._v("和"),t("code",[v._v("const")]),v._v("的行为很多时候与"),t("code",[v._v("var")]),v._v("一致。然而，它们在循环中的行为却不一样。在"),t("code",[v._v("for-in")]),v._v("和"),t("code",[v._v("for-of")]),v._v("循环中，"),t("code",[v._v("let")]),v._v(" 和"),t("code",[v._v("const")]),v._v("都会每次选代时创建新绑定，从而使循环体内创建的函数可以访问到相应迭代的值，而非最后一次迭代后的值（像使用var那样）。"),t("code",[v._v("let")]),v._v(" 在"),t("code",[v._v("for")]),v._v("循环中同样如此，但在于"),t("code",[v._v("for")]),v._v("循环中使用"),t("code",[v._v("const")]),v._v("声明则可能引发错误。")]),v._v(" "),t("div",{staticClass:"custom-block tip"},[t("p",{staticClass:"custom-block-title"},[v._v("实践建议")]),v._v(" "),t("p",[v._v("默认使用"),t("code",[v._v("const")]),v._v(" ，只在确实需要改变变量的值时使用"),t("code",[v._v("let")]),v._v(" 。这样就可以在某种程度上实现代码的不可变，从而防止某些错误的产生。")])]),v._v(" "),t("h3",{attrs:{id:"字符串与正则表达式"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#字符串与正则表达式"}},[v._v("#")]),v._v(" 字符串与正则表达式")]),v._v(" "),t("p",[v._v("字符串匹配以前用"),t("code",[v._v("indexOf(指定文本)")]),v._v("方法, 判断"),t("code",[v._v("指定文本")]),v._v("在字符串的索引值, 不存在则返回"),t("code",[v._v("-1")]),v._v("."),t("br"),v._v("\nES6新增下面方法:")]),v._v(" "),t("ul",[t("li",[t("code",[v._v("includes(指定文本, [搜索位置索引])")]),v._v("方法: 判断字符串中是否含有"),t("code",[v._v("指定文本")]),v._v(".")]),v._v(" "),t("li",[t("code",[v._v("startsWith(指定文本, [搜索位置索引])")]),v._v("方法: 判断字符串是否以"),t("code",[v._v("指定文本")]),v._v("开始.")]),v._v(" "),t("li",[t("code",[v._v("endsWith(指定文本, [搜索位置索引])")]),v._v("方法: 判断字符串是否以"),t("code",[v._v("指定文本")]),v._v("结尾.")]),v._v(" "),t("li",[t("code",[v._v("repeat(n)")]),v._v("方法: 将字符串重复n次并返回.")])])])}),[],!1,null,null,null);_.default=o.exports}}]);