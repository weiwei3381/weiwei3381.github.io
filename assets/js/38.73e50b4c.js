(window.webpackJsonp=window.webpackJsonp||[]).push([[38],{407:function(v,_,t){"use strict";t.r(_);var a=t(19),e=Object(a.a)({},(function(){var v=this,_=v.$createElement,t=v._self._c||_;return t("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[t("h1",{attrs:{id:"正则表达式"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#正则表达式"}},[v._v("#")]),v._v(" 正则表达式")]),v._v(" "),t("h2",{attrs:{id:"正则语法"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#正则语法"}},[v._v("#")]),v._v(" 正则语法")]),v._v(" "),t("h3",{attrs:{id:"单个字符"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#单个字符"}},[v._v("#")]),v._v(" 单个字符")]),v._v(" "),t("ol",[t("li",[v._v("换行符："),t("code",[v._v("\\n")]),v._v("，记忆方法："),t("strong",[v._v("n")]),v._v("ew line;")]),v._v(" "),t("li",[v._v("换页符："),t("code",[v._v("\\f")]),v._v("，记忆方法："),t("strong",[v._v("f")]),v._v("orm feed;")]),v._v(" "),t("li",[v._v("回车符："),t("code",[v._v("\\r")]),v._v("，记忆方法："),t("strong",[v._v("r")]),v._v("eturn;")]),v._v(" "),t("li",[v._v("空白符："),t("code",[v._v("\\s")]),v._v("，记忆方法："),t("strong",[v._v("s")]),v._v("pace;")]),v._v(" "),t("li",[v._v("制表符："),t("code",[v._v("\\t")]),v._v("，记忆方法："),t("strong",[v._v("t")]),v._v("able;")])]),v._v(" "),t("h3",{attrs:{id:"多个字符"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#多个字符"}},[v._v("#")]),v._v(" 多个字符")]),v._v(" "),t("ol",[t("li",[v._v("定义集合："),t("code",[v._v("[]")]),v._v("，例如"),t("code",[v._v("/[123]/")]),v._v("可以同时匹配 1，2，3 三个字符；")]),v._v(" "),t("li",[t("code",[v._v("[0-9]")]),v._v("匹配所有数字，"),t("code",[v._v("[a-z]")]),v._v("匹配所有小写英文字母，"),t("code",[v._v("[A-Z]")]),v._v("匹配所有小写英文字母， "),t("code",[v._v("[\\u4e00-\\u9fa5]")]),v._v("匹配所有的汉子；")]),v._v(" "),t("li",[v._v("匹配除了换行符之外的任何字符："),t("code",[v._v(".")]),v._v("，记忆方法：代表句号，表示除了句子结束符")]),v._v(" "),t("li",[v._v("匹配单个数字[0-9]，"),t("code",[v._v("\\d")]),v._v("，记忆方法："),t("strong",[v._v("d")]),v._v("igit;")]),v._v(" "),t("li",[v._v("匹配除了[0-9]，"),t("code",[v._v("\\D")]),v._v("，记忆方法："),t("strong",[v._v("not d")]),v._v("igit;")]),v._v(" "),t("li",[v._v("匹配包括下划线在内的单个字符，[A-Za-z0-9_]，"),t("strong",[v._v("\\w")]),v._v("，记忆方法："),t("strong",[v._v("w")]),v._v("ord;")]),v._v(" "),t("li",[v._v("匹配非单字字符，"),t("code",[v._v("\\W")]),v._v("，记忆方法："),t("strong",[v._v("not w")]),v._v("ord;")]),v._v(" "),t("li",[v._v("匹配空白字符,包括空格、制表符、换页符和换行符，"),t("strong",[v._v("\\s")]),v._v("，记忆方法："),t("strong",[v._v("s")]),v._v("pace；")]),v._v(" "),t("li",[v._v("匹配非空白字符，"),t("code",[v._v("\\S")]),v._v("，记忆方法："),t("strong",[v._v("not s")]),v._v("pace")])]),v._v(" "),t("h3",{attrs:{id:"匹配次数"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#匹配次数"}},[v._v("#")]),v._v(" 匹配次数")]),v._v(" "),t("ol",[t("li",[v._v("元字符"),t("code",[v._v("?")]),v._v("代表了匹配 1 个字符或 0 个字符，例如同时匹配"),t("code",[v._v("color")]),v._v("和"),t("code",[v._v("colour")]),v._v("，可以使用"),t("code",[v._v("/colou?r/")]),v._v("。")]),v._v(" "),t("li",[v._v("元字符"),t("code",[v._v("*")]),v._v("用来表示匹配同个字符出现 0 次或多次的情况。")]),v._v(" "),t("li",[v._v("元字符"),t("code",[v._v("+")]),v._v("适用于要匹配同个字符出现 1 次或多次的情况。")]),v._v(" "),t("li",[v._v("特定的重复次数：使用元字符"),t("code",[v._v("{")]),v._v("和"),t("code",[v._v("}")]),v._v("用来给重复匹配设置精确的区间范围。如想匹配 3 次'a'，使用/a{3}/，如果匹配至少两次'a'用/a{2,}/，详细信息：\n"),t("ul",[t("li",[t("code",[v._v("{x}")]),v._v(": x 次")]),v._v(" "),t("li",[t("code",[v._v("{min, max}")]),v._v("： 介于 min 次到 max 次之间")]),v._v(" "),t("li",[t("code",[v._v("{min, }")]),v._v(": 至少 min 次")]),v._v(" "),t("li",[t("code",[v._v("{0, max}")]),v._v("： 至多 max 次")])])])]),v._v(" "),t("h3",{attrs:{id:"单词与字符串边界"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#单词与字符串边界"}},[v._v("#")]),v._v(" 单词与字符串边界")]),v._v(" "),t("p",[v._v("单词是构成句子和文章的基本单位，一个常见的使用场景是把文章或句子中的特定单词找出来。这时需要用边界正则表达式"),t("code",[v._v("\\b")]),v._v("，例如对于例句：")]),v._v(" "),t("div",{staticClass:"language-js extra-class"},[t("pre",{pre:!0,attrs:{class:"language-js"}},[t("code",[v._v("The cat scattered his food all over the room"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[v._v(".")]),v._v("\n")])])]),t("p",[v._v("想找 cat 这个单词，如果只是使用"),t("code",[v._v("/cat/")]),v._v("，会同时匹配到 cat 和 scattered 这两处文本。这时需使用边界正则表达式"),t("code",[v._v("\\b")]),v._v("，其中 b 是 boundary 的首字母。在正则引擎里它其实匹配的是能构成单词的字符(\\w)和不能构成单词的字符(\\W)中间的那个位置。上面的例子改写成"),t("code",[v._v("/\\bcat\\b/")]),v._v("这样就能匹配到 cat 这个单词了。")]),v._v(" "),t("p",[v._v("对于字符串来说，元字符"),t("code",[v._v("^")]),v._v("用来匹配字符串的开头。而元字符"),t("code",[v._v("$")]),v._v("用来匹配字符串的末尾。")]),v._v(" "),t("h3",{attrs:{id:"分组"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#分组"}},[v._v("#")]),v._v(" 分组")]),v._v(" "),t("p",[v._v("其中分组体现在：所有以"),t("code",[v._v("(")]),v._v("和"),t("code",[v._v(")")]),v._v("元字符所包含的正则表达式被分为一组，每一个分组都是一个子表达式，它也是构成高级正则表达式的基础。如果只是使用简单的(regex)匹配语法本质上和不分组是一样的，如果要发挥它强大的作用，往往要结合回溯引用的方式。")]),v._v(" "),t("p",[v._v("所谓回溯引用（backreference）指的是模式的后面部分引用前面已经匹配到的子字符串。你可以把它想象成是变量，回溯引用的语法像"),t("code",[v._v("\\1")]),v._v(","),t("code",[v._v("\\2")]),v._v(",....,其中"),t("code",[v._v("\\1")]),v._v("表示引用的第一个子表达式，"),t("code",[v._v("\\2")]),v._v("表示引用的第二个子表达式，以此类推。而"),t("code",[v._v("\\0")]),v._v("则表示"),t("strong",[v._v("整个表达式")]),v._v("。")]),v._v(" "),t("h2",{attrs:{id:"python使用正则表达式"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#python使用正则表达式"}},[v._v("#")]),v._v(" python使用正则表达式")]),v._v(" "),t("h3",{attrs:{id:"python使用正则提取信息"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#python使用正则提取信息"}},[v._v("#")]),v._v(" python使用正则提取信息")]),v._v(" "),t("div",{staticClass:"language-py extra-class"},[t("pre",{pre:!0,attrs:{class:"language-py"}},[t("code",[t("span",{pre:!0,attrs:{class:"token keyword"}},[v._v("import")]),v._v(" re\n\np "),t("span",{pre:!0,attrs:{class:"token operator"}},[v._v("=")]),v._v(" re"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[v._v(".")]),t("span",{pre:!0,attrs:{class:"token builtin"}},[v._v("compile")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[v._v("(")]),t("span",{pre:!0,attrs:{class:"token string"}},[v._v('"正则表达式"')]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[v._v(")")]),v._v("  "),t("span",{pre:!0,attrs:{class:"token comment"}},[v._v("# 对正则表达式字符串进行编译")]),v._v("\n")])])])])}),[],!1,null,null,null);_.default=e.exports}}]);